# # import random
# # import math
# # import os
# #
# # import numpy as np
# # import pandas as pd
# #
# # from pysc2.agents import base_agent
# # from pysc2.lib import actions
# # from pysc2.lib import features
# # from utils import *
# #
# #
# # class DQNAgent(base_agent.BaseAgent):
# #
# #     def __init__(self):
# #         super().__init__()
# #         self.previous_state = None
# #         self.previous_action = None
# #         self.model = model
# #         self.memory = memory
# #         self.optimizer = optimizer
# #         self.diagnostics = [0, 0, 0]
# #         self.base_top_left = None
# #         self.supply_depot_built = False
# #         self.scv_selected = False
# #         self.barracks_built = False
# #         self.barracks_selected = False
# #         self.barracks_rallied = False
# #         self.army_selected = False
# #         self.army_rallied = False
# #
# #
# #     def step(self, obs):
# #         super().step(obs)
# #
# #         player_relative = obs.observation['screen'][_PLAYER_RELATIVE]
# #         player_y, player_x = (player_relative == _PLAYER_SELF).nonzero()
# #
# #         can_move = _MOVE_SCREEN in obs.observation["available_actions"]
# #         player_located = player_y.any()
# #         unit_type = obs.observation['screen'][_UNIT_TYPE]
# #
# #         # position = [int(player_x.mean()), int(player_y.mean())]
# #
# #         cc_y, cc_x = (unit_type == _TERRAN_COMMANDCENTER).nonzero()
# #         cc_count = 1 if cc_y.any() else 0
# #
# #         depot_y, depot_x = (unit_type == _TERRAN_BARRACKS).nonzero()
# #         supply_depot_count = int(round(len(depot_y) / 69))
# #
# #
# #         barracks_y, barracks_x = (unit_type == _TERRAN_BARRACKS).nonzero()
# #         barracks_count = int(round(len(barracks_y) / 137))
# #
# #         supply_used = obs.observation['player'][3]
# #         supply_limit = obs.observation['player'][4]
# #         army_supply = obs.observation['player'][5]
# #         worker_supply = obs.observation['player'][6]
# #
# #         supply_free = supply_limit - supply_used
# #
# #         if self.move_number == 0:
# #             self.move_number += 1
# #
# #             current_state = np.zeros(12)
# #             current_state[0] = cc_count
# #             current_state[1] = supply_depot_count
# #             current_state[2] = barracks_count
# #             current_state[3] = obs.observation['player'][_ARMY_SUPPLY]
# #
# #         hot_squares = np.zeros(12)
# #         enemy_y, enemy_x = (obs.observation['screen'][_PLAYER_RELATIVE]== _PLAYER_HOSTILE).nonzero()
# #         for i in range(0, len(enemy_y)):
# #             y = int(math.ceil((enemy_y[i] + 1) / 32))
# #             x = int(math.ceil())
# #         state = torch.FloatTensor(
# #             [[float(can_move), float(player_located), float(unit_type)]])
# #
# #
# #         action = self.select_action(state, self.episodes)
# #         if self.base_top_left is None:
# #             player_y, player_x = (obs.observation["minimap"][_PLAYER_RELATIVE] == _PLAYER_SELF).nonzero()
# #             self.base_top_left = player_y.mean() <= 31
# #
# #
# #
# #
# #
# #
# #
# #         if action == _MOVE_SCREEN and check_available(obs, action):
# #             function_action = _MOVE_SCREEN
# #             target = [_NOT_QUEUED, position]
# #
# #
# #
# #
# #
# #
# #
# #
# #         elif action == _SELECT_ARMY and check_available(obs, action):
# #             unit_y, unit_x = (unit_type == _TERRAN_COMMANDCENTER).nonzero()
# #             if unit_y.any():
# #                 target = transformLocation(
# #                     int(unit_x.mean()), 0, int(unit_y.mean()), 20)
# #                 function_action = _BUILD_SUPPLY_DEPOT
# #                 target = [_NOT_QUEUED, target]
# #
# #
# #         elif action == _BUILD_SUPPLY_DEPOT and check_available(obs, action):
#
# #
# #
# #
# #         else:
# #             function_action = _NO_OP
# #             target = []
# #
# #         if self.previous_state is None:
# #             self.previous_action = action
# #             self.previous_state = state
# #             return actions.FunctionCall(_NO_OP, [])
# #
# #         # Store the transition in memory
# #         self.memory.push(self.previous_state,
# #                          self.previous_action, state, self.reward)
# #
# #         # Sample transitions and transpose
# #         transitions = self.memory.sample(BATCH_SIZE)
# #         batch = Transition(*zip(*transitions))
# #
# #         self.optimize(batch)
# #
# #         self.previous_action = action
# #         self.previous_state = state
# #
# #         self.diagnostics[action] += 1
# #
# #         print(self.diagnostics)
# #
# #         time.sleep(0.3)
# #         return actions.FunctionCall(function_action, target)
#
#     elif check_available(_SELECT_POINT) and smart_action == ACTION_SELECT_SCV:
#         unit_type = obs.observation['screen'][_UNIT_TYPE]
#         unit_y, unit_x = (unit_type == _TERRAN_SCV).nonzero()
#
#         if unit_y.any():
#             i = random.randint(0, len(unit_y) - 1)
#             function_action = _SELECT_POINT
#             target = [_NOT_QUEUED, [unit_x[i], unit_y[i]]]
